from dataclasses import dataclass
#(это библиотеке) декоратор, который мы можем добавить нашему классу




from enum import Enum
#В данном случаем status это тип данных, который представляет собой перечисление возможных значений. Статус может принимать значения из определенного списка. В нашем случае это либо worker, либо student
# И так как статус тоже является привелегий юзеров, созданим новый класс. Для таких типов данных нужна библиотека
class Status(Enum): #Enum - этого готовый класс, который мы можем себе унаследовать для сравнения данных
    #указываем все возможные значение нашего класса
    student = "student" #название атрибута и его значения, которые получим из CSV
    worker = "worker"




USERS_ADULT_AGE = 18 #добавляем констанку, т.к. мы знаем что она постоянна и не изменится

#классы с большой буквы

#список полей (признаков юзера), которые будут в классе User

@dataclass #dataclass говорит, что абстракция USERS это абстракция над данными, а если это данные, мы можем совершать операции (и не нужно писать функции сравнения и т.п.)
class User:
    #описали как должен выглядить пользователь (в данном примере имеет 4 поля)
    #каждый тип полей имеет свой тип данных
    #описали шаблон нашего пользователя
    name: str # имя это строка
    age: int # возраст это число
    #status: str # статус это число
    status: Status #указываем класс и теперь везде, где нужно указать статус, пишем status.student или status.worker
    items: list[str] # items это список

    #чтобы воспользоваться этим шаблоном, нужно описать конструктор класса, т.е. как мы можем использовать наш класс в коде
    #для этого используется __init__ - инициализация нашего класса, в который мы описываем те данные, которые нам нужны

    #!!!!!
    #Добавление функции проверки возраста в класс, т.к. эта функция специфична только для юзера
    def is_adult(self):
        return self.age >= USERS_ADULT_AGE #return - возвращаем тру или фолс, старше 18 лет или нет



#создаем класс worker, который унаследует класс Users
#Делается для того, что мы уже знаем, что у работяги будет статус воркер для исключения дублей
class Worker(User):
    status = Status.worker #у работяги всегда будет статус воркера

    #и далее переопределяем функцию
    def __init__(self, name, age, items):
        self.name = name
        self.age = age
        #$self.status = status #СТАТУС не указываем, т.к. у работяги 1 статус
        self.items = items



'''
ВОТ ЭТО НАМ НЕ ПОНАДОБИТЬСЯ, ТАК КАК МЫ К КЛАССУ ДОБАВИЛИ ДЕКОРАТОР @dataclass, который сразу указывает, что в классе данные и предоставляет под капотом функции

    def __init__(self, name, age, status, items):
        self.name = name
        self.age = age
        self.status = status
        self.items = items

    #в классе можно написать функцию, которая будет сравнивать объекты разных классов между собой
    #в нашем случае она вызовится в момент оператора == (assert oleg == oleg2)
    def __eq__(self, other): #Return возвращает значение функции, возвращать означает выдать результат вычисления функции. В нашем случае TRUE или FALSE
        return (self.name == other.name and
                self.age == other.age and
                self.status == other.status and
                self.items == other.items)
    #self - этот тот класс, который мы сравниваем (в нашем случае oleg)
    #other - тот класс, с которым мы сравниваем (в нашем случае oleg2)
    #----------------
    # также есть и другие функции для работы с данные, например:
    # __add__ один объект добавить к другому (склеиваем строки, складываем числа)
    #__ge__ , __gt__ - >,<,<=,>=

'''

#пример работы
if __name__ == '__main__':
    #"Oleg;16;student;book,pen,paper"
    d = {"name":"Oleg",
         "age":16,
         "status":"student",
         "items": ["book","pen", "paper"]}

    #берем нашего юзера как класс и инициализируем
    #в момент вызова скобок () в классе User и перечисляем все аргументы, которые должны быть переданы, они будут переданы в __init__
    #дальше произойдет инициализация нашего пользователя, все атрибуты положаться в атрибуты соответствующего класса
    # и после этого Олег будет представлять собой экземпляр данного класса
    #КЛАСС - это абстракция над какими-то данными, например над пользователями и мы можем описать конкретные экземпляры данного класса, прописав в него конкретные атрибуиты (поля), которые будут отличать экземпляры между собой
    oleg = User(name="Olef", age=16, status=Status.student, items=["book","pen", "paper"])
    olga = User(name="Olga", age=18, status=Status.worker, items=["book", "paper"])


    #!!!!!теперь мы можем создать воркера, не указывая статус
    olga_worker = User(name="Olga", age=18, items=["book", "paper"])


    print() #как заглушка, не обращать внимания
    #получается, что у нас есть 2 экземпляра одно класса и эти экземпляры никак не связаны, т.е. относятся к одному классу, имеет набор одинаковых полей, но с разнывми значениями

    '''
    #КАК их использовать в коде
    #в отличие от словарей, обращение удобное, т.к. после точки появляется всё, что нам нужно (например все поля, которые у этого класса есть)
    #вместо описания как в словаре user["age"], пишем oleg.age
    assert oleg.age == 18
    assert olga.age == 16

    #00:47:50 продолжение по классам (изменение класса - еще и изменять можно, кроме чтения)
    #пример:
    oleg.age += 1
    assert olga.age == 19
    '''
    #--------------------------------------------------------
    #СЦЕНАРИЙ - ПРОВЕРКА ДАННЫХ ИЗ 3 РАЗНЫХ ИСТОЧНИКОВ (например данные из бд, из файла, их апи)
    #в случае со словарями, мы бы создали 3 функции на вытягивание данных и только потом сравнивали

    #в данном случае класс - абстракция над всеми тремя источниками
    oleg = User(name="Olef", age=16, status=Status.student, items=["book", "pen", "paper"])
    oleg2 = User(name="Olef", age=16, status=Status.worker, items=["book", "pen", "paper"])
    assert oleg == oleg2 #в данном случае они не равны. при прямом сравнивании классы сравниваются по учатску памяти, где они занимают
    #Oleg - <__main__.User object at 0x000001F855559D10>
    #Oleg2 - <__main__.User object at 0x000001F85559C8A0>
    #можно написать функцию, которая сравнит каждое поле, но это долго, догоро и страшно
